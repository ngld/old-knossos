## Copyright 2017 Knossos authors, see NOTICE file
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##     http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.

from __future__ import absolute_import, print_function

import ctypes.util
import json
import logging
import os
import re
import shlex
import stat
import subprocess
import sys
import threading
import time
from subprocess import CalledProcessError

from . import uhf

uhf(__name__)
from . import center, repo, util, settings
from .qt import QtCore, QtWidgets, run_in_qt

# TODO: What happens if a SONAME contains a space?
FILE_PATH_RE = r'[a-zA-Z0-9\./\-\_\+]+'
LDD_RE = re.compile(r'\s*(' + FILE_PATH_RE + r') (?:=> (not found|' + FILE_PATH_RE + r'))?(?: \([^\)]+\))?\s*')
LIB_RE = re.compile(r'lib([a-zA-Z0-9\.\-\_\+]+)\.so(?:\..*)?')
LDCONF_RE = re.compile(r'\s*(' + FILE_PATH_RE + r') \([^\)]+\) => (' + FILE_PATH_RE + r')')
LDDNOTDYNAMIC_RE = re.compile(r'\s*not a dynamic executable')
_LIB_CACHE = None

watchers = []
translate = QtCore.QCoreApplication.translate


class Fs2Watcher(threading.Thread):
    _params = None
    _cwd = None

    def __init__(self, params, cwd):
        super(Fs2Watcher, self).__init__()

        self._params = params
        self._cwd = cwd
        self.daemon = True
        self.start()

        watchers.append(self)

    def run(self):
        bridge = center.main_win.browser_ctrl.bridge
        bridge.fs2Launching.emit()
        launch_script = None

        try:
            fs2_bin = os.path.normpath(self._params[0])

            if not os.path.isfile(fs2_bin):
                self.fs2_missing_msg(fs2_bin)
                return

            mode = os.stat(fs2_bin).st_mode
            if mode & stat.S_IXUSR != stat.S_IXUSR:
                # Make it executable.
                os.chmod(fs2_bin, mode | stat.S_IXUSR)

            env = os.environ.copy()
            if sys.platform.startswith('linux'):
                ld_path, missing = fix_missing_libs(fs2_bin)
                if len(missing) > 0:
                    self.complain_missing(missing)
                    return

                env['LD_LIBRARY_PATH'] = ld_path

            logging.info('Launching FS2: %s in %s', repr([fs2_bin] + self._params[1:]), self._cwd)

            if not self.prepare_fso_config(fs2_bin):
                return

            if sys.platform == 'win32':
                name = os.path.basename(fs2_bin)
                launch_script = os.path.join(self._cwd, 'start_fs2.bat')

                if name.lower().startswith('fred2_open') and not os.path.isfile(launch_script):
                    fso_bin = os.path.join(os.path.dirname(fs2_bin), name.lower().replace('fred2_open', 'fs2_open'))

                    with open(launch_script, 'w', errors='replace') as hdl:
                        hdl.write('@rem Generated by Knossos to work around the FRED bug #1775\n')
                        hdl.write('@cd "%s"\n' % self._cwd)

                        # Not a clean solution but shlex.quote doesn't work on Windows
                        # and escaping like this should be fine for FSO parameters
                        hdl.write('@' + ' '.join(['"%s"' % p for p in [fso_bin] + self._params[1:]]) + '\n')
                elif name.lower().startswith('qtfred') and not os.path.isfile(launch_script):
                    fso_bin = os.path.join(os.path.dirname(fs2_bin), name.lower().replace('qtfred', 'fs2_open'))

                    with open(launch_script, 'w', errors='replace') as hdl:
                        hdl.write('@rem Generated by Knossos to work around the FRED bug #1775\n')
                        hdl.write('@cd "%s"\n' % self._cwd)

                        # Not a clean solution but shlex.quote doesn't work on Windows
                        # and escaping like this should be fine for FSO parameters
                        hdl.write('@' + ' '.join(['"%s"' % p for p in [fso_bin] + self._params[1:]]) + '\n')
                else:
                    launch_script = None

            fail = False
            rc = -999
            reason = '???'
            try:
                p = subprocess.Popen([fs2_bin] + self._params[1:], cwd=self._cwd, env=env)

                time.sleep(0.3)
                if p.poll() is not None:
                    rc = p.returncode
                    reason = 'return code: %d' % rc
                    fail = True
            except OSError as exc:
                logging.exception('Failed to launch FS2!')
                reason = str(exc).decode('utf8', 'replace')
                fail = True

            if fail:
                self.failed_msg(reason, fs2_bin)
                return

            bridge.fs2Launched.emit()
            p.wait()
        finally:
            if launch_script:
                os.unlink(launch_script)

            watchers.remove(self)
            bridge.fs2Quit.emit()

    def prepare_fso_config(self, fs2_bin):
        cfg = settings.get_settings()
        settings.save_fso_settings(cfg['fso'])

        if not cfg['fso']['joystick_guid']:
            # No joystick selected
            return True

        sel_guid = cfg['fso']['joystick_guid']
        found_joystick = False
        flags = settings.get_fso_flags(fs2_bin)
        joysticks = settings.get_joysticks()
        if 'joysticks' in flags:
            for joy in flags['joysticks']:
                if joy['guid'] == sel_guid:
                    found_joystick = True
                    break
        else:
            # Old build, use our own joystick list
            for joy in joysticks:
                if joy[0] == sel_guid:
                    found_joystick = True
                    break

        if found_joystick:
            # Everything's fine
            # NOTE: The config already exists in this case since a joystick was selected.
            return True

        sel_guid = center.settings['joystick']['guid']
        try:
            sel_id = int(center.settings['joystick']['id'])
        except ValueError:
            sel_id = 9999

        sel_name = None
        if 'joysticks' not in flags:
            if not sel_guid:
                self.complain_joystick()
                return False

            # Old build, just use our stored values
            cfg['fso']['joystick_guid'] = sel_guid
            cfg['fso']['joystick_id'] = sel_id

            logging.info('Detected old build, used joystick GUID from Knossos settings')
        elif not sel_guid:
            self.complain_joystick()
            return False
        else:
            # Try to guess the correct GUID and ID by using our own GUID and ID as basis
            candidates = []
            for joy in joysticks:
                if joy[0] == sel_guid and joy[1] == sel_id:
                    sel_name = joy[2]
                    break

            for i, joy in enumerate(flags['joysticks']):
                if joy['name'] == sel_name:
                    candidates.append((i, joy))

            if len(flags['joysticks']) == 0:
                logging.info('Skipped joystick mapping because no joysticks were detected.')
                return True

            if len(candidates) == 1:
                # This is easy!
                logging.info('Mapping joystick %s (%d) => %s (%d)', sel_guid, sel_id, candidates[0][1]['guid'], candidates[0][0])

                cfg['fso']['joystick_guid'] = candidates[0][1]['guid']
                cfg['fso']['joystick_id'] = candidates[0][0]
            else:
                joy = [j[1] for j in candidates if j[0] == sel_id]
                if joy:
                    logging.info('Mapping joystick %s => %s (many matched)', sel_guid, joy[0]['guid'])

                    cfg['fso']['joystick_guid'] = joy[0]['guid']
                elif len(candidates) > 0:
                    if len(flags['joysticks']) > sel_id:
                        logging.warning('Mapping joystick %s => %s (based on index)', sel_guid, candidates[sel_id]['guid'])

                        cfg['fso']['joystick_guid'] = candidates[sel_id]['guid']
                    else:
                        logging.error('Joystick mapping failed!')

        settings.save_fso_settings(cfg['fso'])
        return True

    @run_in_qt
    def failed_msg(self, reason, fs2_bin):
        msg = translate('runner', 'Starting %s failed! (%s)') % (fs2_bin, reason)
        QtWidgets.QMessageBox.critical(None, translate('runner', 'Failed'), msg)

    @run_in_qt
    def fs2_missing_msg(self, fs2_bin):
        QtWidgets.QMessageBox.critical(None, 'Knossos',
            translate('runner', 'I can\'t find the selected executable! (The file "%s" is missing!)') % fs2_bin)

    @run_in_qt
    def complain_missing(self, missing):
        if len(missing) > 1:
            msg = translate('runner', "I can't start because the libraries %s are missing!")
        else:
            msg = translate('runner', "I can't start because the library %s is missing!")

        QtWidgets.QMessageBox.critical(None, 'Knossos', msg % util.human_list(missing))

    @run_in_qt
    def complain_joystick(self):
        QtWidgets.QMessageBox.critical(None, 'Knossos', translate('runner',
            "Your fs2_open.ini contains a joystick which this FSO version can't detect and Knossos doesn't remember"
            " your joystick. Please go to Knossos' settings, select your joystick, save and try again."
        ))


def check_elf_libs(fpath):
    try:
        out = util.check_output(['ldd', fpath], env={'LANG': 'C'}).splitlines()
    except CalledProcessError as e:
        result = LDDNOTDYNAMIC_RE.match(e.stdout)
        if result and e.returncode == 1:
            logging.debug('Not continuing to check libs as the executable is not dynamic')
            return {}
        else:
            raise
    except:
        raise

    libs = {}
    for r_line in out:
        line = LDD_RE.match(r_line)
        if not line:
            logging.warning('Failed to parse ldd line "%s"!', r_line)
            continue

        if line.group(2) == 'not found':
            libs[line.group(1)] = None
        elif not line.group(2):
            # This is most likely a line like "linux-vdso.so.1 (0x00007fff847fe000)" which we can ignore.
            continue
        else:
            libs[line.group(1)] = line.group(2)

    return libs


def get_lib_path(filename):
    global _LIB_CACHE

    if not _LIB_CACHE:
        _LIB_CACHE = {}

        try:
            env = os.environ.copy()
            env['LANG'] = 'C'
            data = util.check_output(['ldconfig', '-p'], env=env).splitlines()
        except subprocess.CalledProcessError:
            logging.exception('Failed to run ldconfig!')
            return None

        for line in data[1:]:
            m = LDCONF_RE.match(line)
            if not m:
                logging.warning('Failed to parse ldconfig line "%s"!', line)
                continue

            _LIB_CACHE[m.group(1)] = m.group(2)

    return _LIB_CACHE.get(filename)


def fix_missing_libs(fpath, augment_ldpath=True):
    base = os.path.dirname(fpath)
    patch_dir = os.path.join(base, '__k_plibs')

    # AppImages are a bit special since they are themselves ELF executables which contain the actual FSO executable so
    # it makes no sense to examine the binary for missing libraries. They also might be static execs
    if fpath.lower().endswith(".appimage"):
        return '', []

    libs = check_elf_libs(fpath)
    missing = []
    for name, path in libs.items():
        if not path:
            missing.append(name)

    if len(missing) == 0:
        # Yay, nothing to do.
        if augment_ldpath:
            return os.environ.get('LD_LIBRARY_PATH', ''), missing
        else:
            return '', missing

    for lib in missing[:]:
        p_name = os.path.join(patch_dir, lib)
        if os.path.exists(p_name):
            missing.remove(lib)
        else:
            ld_name = LIB_RE.match(lib)
            if ld_name:
                fixed_name = get_lib_path(ctypes.util.find_library(ld_name.group(1)))
                if fixed_name:
                    if not os.path.isdir(patch_dir):
                        os.mkdir(patch_dir)

                    os.symlink(fixed_name, p_name)
                    missing.remove(lib)

    if augment_ldpath:
        ld_path = os.environ.get('LD_LIBRARY_PATH', '')
        if ld_path != '':
            patch_dir += ':' + ld_path

    return patch_dir, missing


def run_fs2_silent(params):
    base_path = center.settings['base_path']
    fs2_bin = params[0]

    if not os.path.isfile(fs2_bin):
        return -128, None

    mode = os.stat(fs2_bin).st_mode
    if mode & stat.S_IXUSR != stat.S_IXUSR:
        # Make it executable.
        os.chmod(fs2_bin, mode | stat.S_IXUSR)

    # We copy the existing environment to avoid omitting any values that may be necessary for running the binary
    # properly
    env = dict(os.environ)
    if sys.platform.startswith('linux'):
        ld_path, missing = fix_missing_libs(fs2_bin)
        if len(missing) > 0:
            return -127, None

        env['LD_LIBRARY_PATH'] = ld_path

    try:
        try:
            output = util.check_output(params, env=env, cwd=base_path, stderr=subprocess.DEVNULL, no_hide=True)
            rc = 0
        except CalledProcessError as e:
            # check_output raises this error if the return code was anything other than 0
            rc = e.returncode
            output = e.output
    except OSError:
        return -129, None

    if rc == 3221225595:
        # We're missing a DLL
        return -127, None

    return rc, output


def run_mod(mod, tool=None, exe_label=None):
    global installed

    if mod is None:
        mod = repo.Mod()

    try:
        inst_mod = center.installed.query(mod)
    except repo.ModNotFound:
        inst_mod = None

    if not inst_mod:
        QtWidgets.QMessageBox.critical(None, translate('runner', 'Error'),
            translate('runner', 'The mod "%s" could not be found!') % mod)
        return

    exes = []

    if tool:
        try:
            exes = tool.get_executables()
            # TODO check whether repo.NoExecutablesFound exception applies here
        except Exception:
            logging.exception('Failed to retrieve binaries for "%s"!' % tool.mid)
            QtWidgets.QMessageBox.critical(None, translate('runner', 'Error'),
                translate('runner', "I couldn't find the tool's executables! Aborted."))
            return
    else:
        try:
            exes = mod.get_executables(user=True)
        except repo.NoExecutablesFound:
            logging.error('"%s" provided no executable.' % mod.mid)
            msg = 'No executable was found for this mod!'
            if mod.dev_mode:
                msg += ' Make sure you have an FSO build selected on the FSO tab.'
            QtWidgets.QMessageBox.critical(
                None, 'Knossos', translate('runner', msg))
            return
        except Exception:
            logging.exception('Failed to retrieve binaries for "%s"!' % mod.mid)
            QtWidgets.QMessageBox.critical(None, translate('runner', 'Error'),
                translate('runner', "I couldn't find an executable. Aborted."))
            return

    exes = [item for item in exes if item.get('label', None) == exe_label]
    if len(exes) == 0:
        logging.error('"%s" provided no valid executable.' % (tool or mod).mid)
        QtWidgets.QMessageBox.critical(None, 'Knossos',
            translate('runner', 'No matching executable was found!'))
        return

    try:
        mod_flag, mod_choice = mod.get_mod_flag()
    except repo.ModNotFound as exc:
        mod_name = exc.mid
        if exc.spec:
            details = ' (%s)' % exc.spec
        else:
            details = ''

        try:
            err_mod = center.mods.query(mod_name).title
        except repo.ModNotFound:
            err_mod = mod_name

        if err_mod:
            if isinstance(exc, repo.PackageConstraintNotMet):
                QtWidgets.QMessageBox.critical(None, 'Knossos',
                    translate('runner', '"%s" (%s) requires "%s" which has conflicting requirements: %s' % (mod.title, mod.version, err_mod, exc.spec)))
            else:
                QtWidgets.QMessageBox.critical(None, 'Knossos',
                    translate('runner', '"%s" (%s) requires "%s" which is missing! %s' % (mod.title, mod.version, err_mod, details)))
        else:
            QtWidgets.QMessageBox.critical(None, 'Knossos',
                translate('runner', '"%s" has an error in its dependencies. Aborted.' % mod))
        return

    global_flags = get_global_flags(mod)
    sel_exe = exes[0]
    if global_flags and '#exe' in global_flags:
        for exe in exes:
            if os.path.basename(exe['file']) == global_flags['#exe']:
                sel_exe = exe
                break

    if mod_choice:
        # We have to ask the user
        options = []
        files = set()

        for exe in exes:
            if exe['file'] not in files:
                basename = os.path.basename(exe['file'])
                options.append((exe['file'], '%s - %s' % (exe['mod'].title, basename)))
                files.add(exe['file'])

        center.main_win.browser_ctrl.bridge.showLaunchPopup.emit(json.dumps({
            'id': mod.mid,
            'version': str(mod.version),
            'title': mod.title,
            'exes': options,
            'is_tool': bool(tool),
            'mod_flag': mod_flag,
            'selected_exe': sel_exe['file']
        }))
    else:
        run_mod_ex(mod, sel_exe['file'], [path for path, label in mod_flag], bool(tool))


def run_mod_ex(mod, binpath, mod_flag, is_tool):
    if not is_tool:
        mod.update_last_played()

    # Put the cmdline together
    if mod.user_cmdline:
        cmdline = shlex.split(mod.user_cmdline)
    else:
        cmdline = apply_global_flags(mod)

    if mod.mtype == 'mod':
        parent = mod.get_parent()

        if parent.mid == 'FS2':
            basepath = parent.folder
        else:
            basepath = os.path.dirname(parent.folder)

            found = False
            for pkg in mod.packages:
                for dep in pkg.dependencies:
                    if dep['id'] == parent.mid:
                        found = True
                        break

                if found:
                    break

            if not found:
                logging.debug("Mod %s doesn't depend on parent, fixing mod flags...", mod)
                mod_flag.extend([p[0] for p in parent.get_mod_flag()[0]])
    elif mod.mtype == 'tc':
        basepath = os.path.dirname(mod.folder)
    elif mod.mtype:
        basepath = mod.folder

    if len(mod_flag) > 0:
        # The paths for -mod must be relative to the base path.
        # TODO: Do we have to make sure that there are no special characters here or are the rules for mod.folder and
        #       pkg.folder enough to assure that?
        cmdline.append('-mod')
        cmdline.append(','.join([os.path.relpath(p, basepath) for p in mod_flag]))

    # We put all arguments in the command line so we can skip the config file
    cmdline.append('-parse_cmdline_only')

    logging.info('Starting mod "%s" with cmdline "%s" and tool "%s".', mod.title, cmdline, binpath)
    Fs2Watcher([binpath] + cmdline, cwd=basepath)


def stringify_cmdline(line):
    result = []
    for part in line:
        if '"' in part:
            raise Exception("It's impossible to pass double quotes to FSO!")

        if ' ' in part:
            part = '"%s"' % part

        result.append(part)

    return ' '.join(result)


def get_global_flags(mod):
    try:
        builds = mod.get_executables(user=True)
    except Exception:
        logging.exception('Failed to retrieve flags for %s.' % mod)
        return None

    if len(builds) == 0:
        build = None
    else:
        build = builds[0]
        if build['mod'] == mod and not build['label']:
            # a custom build
            build = 'custom#' + build['file']
        else:
            build = '%s#%s' % (build['mod'].mid, build['mod'].version)

    if not build:
        logging.warn('Failed to retrieve global flags for %r because I couldn\'t determine the build.' % mod)
        return None

    return center.settings['fso_flags'].get(build)


def apply_global_flags(mod):
    flag_states = get_global_flags(mod)
    if not flag_states:
        # No global flags set
        return shlex.split(mod.cmdline)

    custom_flags = []
    if '#custom' in flag_states:
        custom_flags = shlex.split(flag_states['#custom'])

    cmdline = shlex.split(mod.cmdline)
    for flag, state in flag_states.items():
        if flag.startswith('#'):
            continue

        if state == 0:
            # Off
            if flag in cmdline:
                cmdline.remove(flag)
        elif state == 2:
            # On
            if flag not in cmdline:
                cmdline.append(flag)

    return [shlex.quote(p) for p in cmdline] + custom_flags
